<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å±‚çº§å…³ç³»å›¾æŸ¥çœ‹å™¨</title>
    <script src="./d3.v7.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        .container {
            max-width: 1800px; margin: 0 auto; background: white;
            border-radius: 15px; box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden; display: grid;
            grid-template-columns: 1fr 350px;
            grid-template-rows: auto auto 1fr;
            min-height: calc(100vh - 40px);
        }
        .header {
            grid-column: 1 / -1; background: linear-gradient(135deg, #2c3e50, #3498db);
            color: white; padding: 30px; text-align: center;
        }
        .controls {
            grid-column: 1 / -1; padding: 30px; background: #f8f9fa;
            border-bottom: 2px solid #e9ecef;
        }
        .file-input-button, .search-button {
            background: linear-gradient(135deg, #28a745, #20c997);
            color: white; padding: 12px 25px; border-radius: 8px;
            cursor: pointer; border: none; font-size: 16px;
            transition: all 0.3s ease; margin-right: 10px;
        }
        .search-button { background: linear-gradient(135deg, #3498db, #2980b9); }
        .file-options {
            margin: 15px 0; padding: 15px; background: #e9ecef;
            border-radius: 8px; display: none;
        }
        .search-input, select {
            padding: 12px 15px; border: 2px solid #ddd;
            border-radius: 8px; font-size: 16px; margin-right: 10px;
        }
        .tree-container {
            padding: 20px; background: white; overflow: hidden; position: relative;
        }
        #tree-svg { width: 100%; height: 100%; border: 1px solid #e9ecef; border-radius: 10px; }
        .sidebar {
            background: #f8f9fa; border-left: 2px solid #e9ecef;
            padding: 20px; overflow-y: auto; display: flex;
            flex-direction: column; gap: 20px;
        }
        .detail-panel {
            background: white; border-radius: 10px; padding: 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        .detail-panel h3 {
            color: #2c3e50; margin-bottom: 15px; font-size: 18px;
            border-bottom: 2px solid #3498db; padding-bottom: 8px;
        }
        #nodeDetailContent {
            max-height: 400px;
            overflow-y: auto;
            overflow-x: hidden;
        }
        #nodeDetailContent::-webkit-scrollbar {
            width: 6px;
        }
        #nodeDetailContent::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 3px;
        }
        #nodeDetailContent::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 3px;
        }
        #nodeDetailContent::-webkit-scrollbar-thumb:hover {
            background: #a8a8a8;
        }
        .info-item {
            background: #f8f9fa; padding: 8px 12px; border-radius: 6px;
            border-left: 3px solid #3498db; margin-bottom: 8px;
        }
        .info-label { font-size: 12px; color: #6c757d; margin-bottom: 2px; }
        .info-value { 
            font-weight: bold; color: #2c3e50;
        }
        .node { cursor: pointer; transition: all 0.3s ease; }
        .node circle {
            fill: #fff; stroke: #3498db; stroke-width: 2px; transition: all 0.3s ease;
        }
        .node.selected circle { fill: #3498db; stroke: #2980b9; stroke-width: 3px; }
        .node:hover circle { fill: #e8f4fd; stroke: #2980b9; stroke-width: 3px; }
        .node text { font: 12px sans-serif; fill: #2c3e50; text-anchor: middle; pointer-events: none; }
        .link { fill: none; stroke: #bdc3c7; stroke-width: 1.5px; }
        .root-indicator { fill: #e74c3c; stroke: #c0392b; }
        .loading, .no-data { text-align: center; padding: 60px; color: #6c757d; font-size: 18px; }
        .tree-controls {
            position: absolute; top: 10px; right: 10px; display: flex; gap: 5px;
        }
        .tree-control-btn {
            background: #3498db; color: white; border: none;
            padding: 6px 10px; border-radius: 5px; cursor: pointer; font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸŒ³ å±‚çº§å…³ç³»å›¾æŸ¥çœ‹å™¨</h1>
        </div>
        
        <div class="controls">
            <input type="file" id="fileInput" accept=".txt,.csv" style="display: none;" />
            <label for="fileInput" class="file-input-button">ğŸ“‚ é€‰æ‹©æ•°æ®æ–‡ä»¶</label>
            
            <div class="file-options" id="fileOptions">
                <select id="separatorSelect">
                    <option value="\t">åˆ¶è¡¨ç¬¦ (Tab)</option>
                    <option value=",">é€—å· (,)</option>
                    <option value=";">åˆ†å· (;)</option>
                    <option value="|">ç«–çº¿ (|)</option>
                </select>
                <label><input type="checkbox" id="hasHeaderCheck" checked /> æ–‡ä»¶åŒ…å«è¡¨å¤´</label>
                <button id="parseFileButton" class="search-button">ğŸ“‹ è§£ææ–‡ä»¶</button>
            </div>
            <p>&nbsp;</p>
            <div>
                <input type="text" id="searchInput" class="search-input" placeholder="è¾“å…¥ç”¨æˆ·IDæˆ–å…¶ä»–ä¿¡æ¯æœç´¢..." />
                <button id="searchButton" class="search-button">ğŸ” æœç´¢</button>
                <button id="resetButton" class="search-button" style="background: linear-gradient(135deg, #dc3545, #c82333);">ğŸ”„ é‡ç½®è§†å›¾</button>
                <select id="rootSelector" style="display: none;">
                    <option value="">é€‰æ‹©æ ¹èŠ‚ç‚¹</option>
                </select>
                <div id="nodeInfoSelector" style="display: none;">
                    <label style="font-size: 14px; margin-right: 10px;">æ˜¾ç¤ºå­—æ®µï¼š</label>
                    <button id="selectAllFields" class="tree-control-btn" style="margin-right: 5px;">å…¨é€‰</button>
                    <button id="selectNoneFields" class="tree-control-btn" style="margin-right: 10px;">æ¸…ç©º</button>
                    <div id="fieldCheckboxes" style="display: inline-block;"></div>
                </div>
            </div>
        </div>

        <div class="tree-container">
            <div class="tree-controls">
                <button class="tree-control-btn" onclick="treeViewer.zoomIn()">æ”¾å¤§</button>
                <button class="tree-control-btn" onclick="treeViewer.zoomOut()">ç¼©å°</button>
                <button class="tree-control-btn" onclick="treeViewer.fitToScreen()">é€‚åº”</button>
                <button class="tree-control-btn" onclick="treeViewer.expandAll()">å±•å¼€</button>
                <button class="tree-control-btn" onclick="treeViewer.collapseAll()">æ”¶èµ·</button>
            </div>
            <svg id="tree-svg"></svg>
            <div id="loadingIndicator" class="no-data">
                è¯·é€‰æ‹©ä¸€ä¸ªæ•°æ®æ–‡ä»¶å¼€å§‹æŸ¥çœ‹å±‚çº§å…³ç³»å›¾<br>
                <small>æ”¯æŒå¤šç§åˆ†éš”ç¬¦æ ¼å¼ï¼šåˆ¶è¡¨ç¬¦ã€é€—å·ã€åˆ†å·ã€ç«–çº¿</small>
            </div>
        </div>

        <div class="sidebar">
            <div class="detail-panel">
                <h3>ğŸ‘¤ èŠ‚ç‚¹è¯¦æƒ…</h3>
                <div id="nodeDetailContent">
                    <p style="color: #6c757d; text-align: center; padding: 20px;">
                        ç‚¹å‡»æ ‘çŠ¶å›¾ä¸­çš„èŠ‚ç‚¹æŸ¥çœ‹è¯¦ç»†ä¿¡æ¯
                    </p>
                </div>
            </div>

            <div class="detail-panel">
                <h3>ğŸ“Š å›¾è¡¨ç»Ÿè®¡</h3>
                <div id="statsContent">
                    <div class="info-item">
                        <div class="info-label">æ€»èŠ‚ç‚¹æ•°</div>
                        <div class="info-value" id="totalNodesCount">0</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">æ ¹èŠ‚ç‚¹æ•°</div>
                        <div class="info-value" id="rootNodesCount">0</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">æœ€å¤§æ·±åº¦</div>
                        <div class="info-value" id="maxDepthValue">0</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">å½“å‰è§†å›¾</div>
                        <div class="info-value" id="currentRootValue">æ— </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class D3TreeViewer {
            constructor() {
                this.data = new Map();
                this.children = new Map();
                this.rootNodes = [];
                this.currentRoot = null;
                this.selectedNode = null;
                this.columnHeaders = [];
                this.fileContent = null;
                this.searchIndex = new Map();
                this.expandedNodes = new Set();
                this.selectedFields = []; // é€‰ä¸­çš„å­—æ®µåˆ—è¡¨

                // D3ç›¸å…³
                this.svg = null;
                this.g = null;
                this.tree = null;
                this.root = null;
                this.zoom = null;
                this.width = 1200;
                this.height = 800;
                
                this.initializeEventListeners();
                this.initializeD3();
            }

            initializeEventListeners() {
                document.getElementById('fileInput').addEventListener('change', (e) => {
                    this.loadFileContent(e.target.files[0]);
                });
                document.getElementById('parseFileButton').addEventListener('click', () => {
                    this.parseFileWithOptions();
                });
                document.getElementById('searchButton').addEventListener('click', () => {
                    this.searchNode();
                });
                document.getElementById('resetButton').addEventListener('click', () => {
                    this.resetView();
                });
                document.getElementById('rootSelector').addEventListener('change', (e) => {
                    this.switchRoot(e.target.value);
                });
                document.getElementById('selectAllFields').addEventListener('click', () => {
                    this.selectAllFields();
                });
                document.getElementById('selectNoneFields').addEventListener('click', () => {
                    this.selectNoneFields();
                });
            }

            initializeD3() {
                this.svg = d3.select("#tree-svg");
                this.zoom = d3.zoom()
                    .scaleExtent([0.1, 4])
                    .on("zoom", (event) => {
                        this.g.attr("transform", event.transform);
                    });
                this.svg.call(this.zoom);
                this.g = this.svg.append("g");
                this.tree = d3.tree().size([this.width - 200, this.height - 100]);
            }

            async loadFileContent(file) {
                if (!file) return;
                document.getElementById('loadingIndicator').innerHTML = '<div class="loading">æ­£åœ¨è¯»å–æ–‡ä»¶...</div>';
                try {
                    this.fileContent = await file.text();
                    this.showFileOptions();
                    document.getElementById('loadingIndicator').innerHTML = '<div class="no-data">è¯·é€‰æ‹©åˆ†éš”ç¬¦å’Œè¡¨å¤´é€‰é¡¹ï¼Œç„¶åç‚¹å‡»"è§£ææ–‡ä»¶"</div>';
                } catch (error) {
                    document.getElementById('loadingIndicator').innerHTML = `<div class="no-data">è¯»å–æ–‡ä»¶å¤±è´¥: ${error.message}</div>`;
                }
            }

            showFileOptions() {
                document.getElementById('fileOptions').style.display = 'block';
                this.autoDetectSeparator();
            }

            autoDetectSeparator() {
                if (!this.fileContent) return;
                const firstLine = this.fileContent.split('\n')[0];
                const separators = {
                    '\t': (firstLine.match(/\t/g) || []).length,
                    ',': (firstLine.match(/,/g) || []).length,
                    ';': (firstLine.match(/;/g) || []).length,
                    '|': (firstLine.match(/\|/g) || []).length
                };
                let maxCount = 0, bestSeparator = '\t';
                for (const [sep, count] of Object.entries(separators)) {
                    if (count > maxCount) { maxCount = count; bestSeparator = sep; }
                }
                document.getElementById('separatorSelect').value = bestSeparator;
            }

            parseFileWithOptions() {
                if (!this.fileContent) { alert('è¯·å…ˆé€‰æ‹©æ–‡ä»¶'); return; }
                document.getElementById('loadingIndicator').innerHTML = '<div class="loading">æ­£åœ¨è§£ææ•°æ®...</div>';
                try {
                    const separator = document.getElementById('separatorSelect').value;
                    const hasHeader = document.getElementById('hasHeaderCheck').checked;
                    this.parseData(this.fileContent, separator, hasHeader);
                    this.buildSearchIndex();
                    this.buildTree();
                    this.setupRootSelector();
                    this.setupNodeInfoSelector();
                    this.renderTree();
                    this.updateStats();
                    document.getElementById('fileOptions').style.display = 'none';
                    document.getElementById('loadingIndicator').style.display = 'none';
                } catch (error) {
                    document.getElementById('loadingIndicator').innerHTML = `<div class="no-data">è§£ææ–‡ä»¶å¤±è´¥: ${error.message}</div>`;
                }
            }

            parseData(text, separator, hasHeader) {
                const lines = text.trim().split('\n');
                this.data.clear(); this.children.clear(); this.columnHeaders = [];
                let startLine = 0;
                if (hasHeader && lines.length > 0) {
                    this.columnHeaders = lines[0].split(separator).map(h => h.trim());
                    startLine = 1;
                } else if (lines.length > 0) {
                    const firstRowCols = lines[0].split(separator);
                    this.columnHeaders = ['ID', 'ä¸Šçº§ID'];
                    for (let i = 2; i < firstRowCols.length; i++) {
                        this.columnHeaders.push(`å­—æ®µ${i - 1}`);
                    }
                }
                for (let i = startLine; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;
                    const parts = line.split(separator).map(s => s.trim());
                    const id = parts[0], parentId = parts[1] || null;
                    if (!id) continue;
                    const nodeData = { id, parentId, level: 0, childCount: 0, directChildren: 0, columns: {} };
                    for (let j = 0; j < Math.min(parts.length, this.columnHeaders.length); j++) {
                        nodeData.columns[this.columnHeaders[j]] = parts[j] || '';
                    }
                    this.data.set(id, nodeData);
                }
                this.rootNodes = [];
                for (const [id, nodeData] of this.data) {
                    const parentId = nodeData.parentId;
                    if (parentId && this.data.has(parentId)) {
                        if (!this.children.has(parentId)) this.children.set(parentId, []);
                        this.children.get(parentId).push(id);
                    } else {
                        this.rootNodes.push(id);
                    }
                }
                this.calculateLevels();
            }

            calculateLevels() {
                const visited = new Set();
                const dfs = (nodeId, level) => {
                    if (visited.has(nodeId) || !this.data.has(nodeId)) return 0;
                    visited.add(nodeId);
                    const nodeData = this.data.get(nodeId);
                    nodeData.level = level;
                    const children = this.children.get(nodeId) || [];
                    nodeData.directChildren = children.length;
                    let totalChildren = 0;
                    for (const childId of children) {
                        totalChildren += 1 + dfs(childId, level + 1);
                    }
                    nodeData.childCount = totalChildren;
                    return totalChildren;
                };
                for (const rootId of this.rootNodes) { dfs(rootId, 1); }
            }

            buildSearchIndex() {
                this.searchIndex.clear();
                for (const [id, nodeData] of this.data) {
                    this.searchIndex.set(id.toLowerCase(), id);
                    for (const [columnName, value] of Object.entries(nodeData.columns)) {
                        if (value && typeof value === 'string' && value.trim()) {
                            this.searchIndex.set(value.toLowerCase(), id);
                            if (columnName.includes('æ‰‹æœº') && value.length >= 4) {
                                this.searchIndex.set(value.slice(-4), id);
                            }
                        }
                    }
                }
            }

            buildTree() {
                for (const [parentId, children] of this.children) {
                    children.sort((a, b) => {
                        const numA = parseInt(a), numB = parseInt(b);
                        if (!isNaN(numA) && !isNaN(numB)) return numA - numB;
                        return a.localeCompare(b);
                    });
                }
                if (this.rootNodes.length > 0) {
                    this.currentRoot = this.rootNodes[0];
                    // é»˜è®¤å±•å¼€æ ¹èŠ‚ç‚¹
                    this.expandedNodes.add(this.currentRoot);
                }
            }

            setupRootSelector() {
                const selector = document.getElementById('rootSelector');
                selector.innerHTML = '<option value="">é€‰æ‹©æ ¹èŠ‚ç‚¹</option>';
                if (this.rootNodes.length > 1) {
                    selector.style.display = 'inline-block';
                    for (const rootId of this.rootNodes) {
                        const nodeData = this.data.get(rootId);
                        const displayName = this.getDisplayName(nodeData);
                        const option = document.createElement('option');
                        option.value = rootId;
                        option.textContent = `${rootId} - ${displayName}`;
                        selector.appendChild(option);
                    }
                    selector.value = this.currentRoot;
                } else {
                    selector.style.display = 'none';
                }
            }
            
            setupNodeInfoSelector() {
                const container = document.getElementById('nodeInfoSelector');
                const checkboxContainer = document.getElementById('fieldCheckboxes');
                
                // æ¸…ç©ºç°æœ‰å†…å®¹
                checkboxContainer.innerHTML = '';
                this.selectedFields = [];
                
                // å¦‚æœæœ‰è¡¨å¤´ï¼Œä¸”è¡¨å¤´é•¿åº¦å¤§äº2ï¼ˆé™¤äº†IDå’Œä¸Šçº§IDï¼‰
                if (this.columnHeaders.length > 2) {
                    for (let i = 2; i < this.columnHeaders.length; i++) {
                        const header = this.columnHeaders[i];
                        if (header && header.trim()) {
                            const checkboxWrapper = document.createElement('label');
                            checkboxWrapper.style.marginRight = '15px';
                            checkboxWrapper.style.cursor = 'pointer';
                            checkboxWrapper.style.fontSize = '13px';
                            checkboxWrapper.style.whiteSpace = 'nowrap';
                            
                            const checkbox = document.createElement('input');
                            checkbox.type = 'checkbox';
                            checkbox.value = header;
                            checkbox.style.marginRight = '5px';
                            
                            // é»˜è®¤é€‰ä¸­ç¬¬ä¸€ä¸ªå­—æ®µ
                            if (i === 2) {
                                checkbox.checked = true;
                                this.selectedFields.push(header);
                            }
                            
                            checkbox.addEventListener('change', (e) => {
                                this.onFieldSelectionChange(e.target.value, e.target.checked);
                            });
                            
                            checkboxWrapper.appendChild(checkbox);
                            checkboxWrapper.appendChild(document.createTextNode(header));
                            checkboxContainer.appendChild(checkboxWrapper);
                        }
                    }
                    container.style.display = 'block';
                } else {
                    // æ²¡æœ‰è¡¨å¤´æˆ–è¡¨å¤´ä¸å¤Ÿï¼Œéšè—é€‰æ‹©å™¨
                    container.style.display = 'none';
                }
            }
            
            onFieldSelectionChange(fieldName, isSelected) {
                if (isSelected) {
                    if (!this.selectedFields.includes(fieldName)) {
                        this.selectedFields.push(fieldName);
                    }
                } else {
                    const index = this.selectedFields.indexOf(fieldName);
                    if (index > -1) {
                        this.selectedFields.splice(index, 1);
                    }
                }
                
                if (this.currentRoot) {
                    this.renderTree();
                }
            }
            
            selectAllFields() {
                const checkboxes = document.querySelectorAll('#fieldCheckboxes input[type="checkbox"]');
                this.selectedFields = [];
                
                checkboxes.forEach(checkbox => {
                    checkbox.checked = true;
                    this.selectedFields.push(checkbox.value);
                });
                
                if (this.currentRoot) {
                    this.renderTree();
                }
            }
            
            selectNoneFields() {
                const checkboxes = document.querySelectorAll('#fieldCheckboxes input[type="checkbox"]');
                this.selectedFields = [];
                
                checkboxes.forEach(checkbox => {
                    checkbox.checked = false;
                });
                
                if (this.currentRoot) {
                    this.renderTree();
                }
            }

            getDisplayName(nodeData) {
                const nicknameFields = ['æ˜µç§°', 'å§“å', 'name', 'nickname'];
                for (const field of nicknameFields) {
                    if (nodeData.columns[field]) return nodeData.columns[field];
                }
                return `ç”¨æˆ·${nodeData.id}`;
            }

            switchRoot(rootId) {
                if (rootId && this.data.has(rootId)) {
                    this.currentRoot = rootId;
                    // åˆ‡æ¢æ ¹èŠ‚ç‚¹æ—¶é‡ç½®å±•å¼€çŠ¶æ€ï¼Œä½†é»˜è®¤å±•å¼€æ–°çš„æ ¹èŠ‚ç‚¹
                    this.expandedNodes.clear();
                    this.expandedNodes.add(rootId);
                    this.renderTree();
                }
            }

            renderTree(animateFromNode = null) {
                if (!this.currentRoot) return;
                
                const hierarchyData = this.buildHierarchyData(this.currentRoot);
                const newRoot = d3.hierarchy(hierarchyData);
                
                // åŠ¨æ€è®¡ç®—æ ‘çš„å°ºå¯¸ï¼ˆå‚ç›´å¸ƒå±€ï¼‰
                const nodeCount = newRoot.descendants().length;
                const avgFieldCount = this.selectedFields.length || 1;
                const treeWidth = Math.max(800, nodeCount * (120 + avgFieldCount * 20));
                this.tree.size([treeWidth, this.height - 100]);
                
                this.tree(newRoot);
                
                // å¦‚æœæ˜¯å±€éƒ¨æ›´æ–°ï¼Œä½¿ç”¨è¿‡æ¸¡åŠ¨ç”»
                const transition = d3.transition().duration(animateFromNode ? 750 : 0);
                
                // æ›´æ–°è¿æ¥çº¿
                const linkSelection = this.g.selectAll(".link")
                    .data(newRoot.links(), d => d.target.data.id);
                
                linkSelection.exit()
                    .transition(transition)
                    .style("opacity", 0)
                    .remove();
                
                linkSelection.enter().append("path")
                    .attr("class", "link")
                    .style("opacity", 0)
                    .transition(transition)
                    .style("opacity", 1)
                    .attr("d", d3.linkVertical().x(d => d.x).y(d => d.y));
                
                linkSelection.transition(transition)
                    .attr("d", d3.linkVertical().x(d => d.x).y(d => d.y));
                
                // æ›´æ–°èŠ‚ç‚¹
                const nodeSelection = this.g.selectAll(".node")
                    .data(newRoot.descendants(), d => d.data.id);
                
                // ç§»é™¤ä¸å†å­˜åœ¨çš„èŠ‚ç‚¹
                nodeSelection.exit()
                    .transition(transition)
                    .style("opacity", 0)
                    .remove();
                
                // æ·»åŠ æ–°èŠ‚ç‚¹
                const nodeEnter = nodeSelection.enter().append("g")
                    .attr("class", "node")
                    .attr("data-node-id", d => d.data.id)
                    .style("cursor", "pointer")
                    .style("opacity", 0)
                    .attr("transform", d => {
                        // å¦‚æœæœ‰åŠ¨ç”»èµ·å§‹èŠ‚ç‚¹ï¼Œä»è¯¥èŠ‚ç‚¹ä½ç½®å¼€å§‹
                        if (animateFromNode) {
                            const sourceNode = newRoot.descendants().find(n => n.data.id === animateFromNode);
                            if (sourceNode) {
                                return `translate(${sourceNode.x},${sourceNode.y})`;
                            }
                        }
                        return `translate(${d.x},${d.y})`;
                    })
                    .on("click", (event, d) => this.handleNodeClick(event, d))
                    .on("contextmenu", (event, d) => {
                        event.preventDefault();
                        this.selectNode(d.data.id);
                    });
                
                // ä¸ºæ–°èŠ‚ç‚¹æ·»åŠ åœ†åœˆ
                this.addNodeCircles(nodeEnter);
                
                // ä¸ºæ–°èŠ‚ç‚¹æ·»åŠ æ–‡æœ¬
                this.addNodeTexts(nodeEnter);
                
                // æ›´æ–°æ‰€æœ‰èŠ‚ç‚¹ä½ç½®
                const nodeUpdate = nodeEnter.merge(nodeSelection);
                
                nodeUpdate.transition(transition)
                    .style("opacity", 1)
                    .attr("transform", d => `translate(${d.x},${d.y})`);
                
                // æ›´æ–°èŠ‚ç‚¹æ ·å¼
                this.updateNodeStyles(nodeUpdate);
                
                this.root = newRoot;
                
                if (!animateFromNode) {
                    this.fitToScreen();
                }
                this.updateStats();
            }
            
            addNodeCircles(nodeSelection) {
                nodeSelection.append("circle")
                    .attr("r", d => {
                        if (d.data.id === this.currentRoot) return 12;
                        const hasChildren = this.children.has(d.data.id) && this.children.get(d.data.id).length > 0;
                        // æ ¹æ®æ˜¾ç¤ºå­—æ®µæ•°é‡è°ƒæ•´åœ†åœˆå¤§å°
                        const baseSize = hasChildren ? 10 : 8;
                        const extraSize = Math.min(this.selectedFields.length * 2, 6);
                        return baseSize + extraSize;
                    });
            }
            
            addNodeTexts(nodeSelection) {
                // æ·»åŠ èŠ‚ç‚¹æ ‡é¢˜ - ä¸Šæ–¹æ˜¾ç¤ºID
                nodeSelection.append("text")
                    .attr("class", "node-title")
                    .attr("dy", "-1.2em")
                    .attr("x", 0)
                    .style("text-anchor", "middle")
                    .style("font-size", "12px")
                    .style("font-weight", "bold")
                    .style("pointer-events", "none")
                    .style("fill", "#2c3e50")
                    .text(d => d.data.id);

                // æ·»åŠ å¤šè¡Œæ•°æ®æ˜¾ç¤º
                nodeSelection.each((d, i, nodes) => {
                    const nodeElement = d3.select(nodes[i]);
                    const nodeData = this.data.get(d.data.id);
                    
                    // ä¸ºæ¯ä¸ªé€‰ä¸­çš„å­—æ®µæ·»åŠ ä¸€è¡Œæ–‡æœ¬
                    this.selectedFields.forEach((fieldName, index) => {
                        const value = nodeData.columns[fieldName];
                        if (value && value.toString().trim()) {
                            const text = value.toString();
                            const displayText = text.length > 10 ? text.substring(0, 10) + '...' : text;
                            const fullDisplayText = `${fieldName}: ${displayText}`;
                            
                            const textElement = nodeElement.append("text")
                                .attr("class", "node-data")
                                .attr("dy", `${2.5 + index * 1.0}em`)
                                .attr("x", 0)
                                .style("text-anchor", "middle")
                                .style("font-size", "10px")
                                .style("pointer-events", "none")
                                .style("fill", "#7f8c8d")
                                .text(fullDisplayText);
                            
                            // æ·»åŠ æ‚¬åœæç¤ºæ˜¾ç¤ºå®Œæ•´å†…å®¹
                            textElement.append("title").text(`${fieldName}: ${text}`);
                        }
                    });
                });

                // æ·»åŠ çŠ¶æ€æŒ‡ç¤ºå™¨ - åœ¨æ•°æ®ä¸‹æ–¹æ˜¾ç¤ºå±•å¼€çŠ¶æ€
                nodeSelection.append("text")
                    .attr("class", "node-status")
                    .attr("dy", d => {
                        // æ ¹æ®æ˜¾ç¤ºçš„å­—æ®µæ•°é‡åŠ¨æ€è°ƒæ•´ä½ç½®
                        const offset = this.selectedFields.length > 0 ? this.selectedFields.length * 1.0 + 0.8 : 1.5;
                        return `${offset}em`;
                    })
                    .attr("x", 0)
                    .style("text-anchor", "middle")
                    .style("font-size", "9px")
                    .style("pointer-events", "none")
                    .style("fill", "#95a5a6")
                    .text(d => {
                        const hasChildren = this.children.has(d.data.id) && this.children.get(d.data.id).length > 0;
                        // if (hasChildren) {
                        //     const childCount = this.children.get(d.data.id).length;
                        //     const isExpanded = this.expandedNodes.has(d.data.id);
                        //     const status = isExpanded ? 'å±•å¼€' : 'æ”¶èµ·';
                        //     return `${status}(${childCount})`;
                        // }
                        return '';
                    });
            }
            
            updateNodeStyles(nodeSelection) {
                // æ›´æ–°åœ†åœˆæ ·å¼
                nodeSelection.select("circle")
                    .attr("class", d => d.data.id === this.currentRoot ? "root-indicator" : "")
                    .style("fill", d => {
                        if (d.data.id === this.currentRoot) {
                            // æ ¹èŠ‚ç‚¹çš„é¢œè‰²ä¹Ÿæ ¹æ®å±•å¼€çŠ¶æ€å˜åŒ–
                            const isExpanded = this.expandedNodes.has(d.data.id);
                            const hasChildren = this.children.has(d.data.id) && this.children.get(d.data.id).length > 0;
                            if (hasChildren && !isExpanded) return "#e67e22"; // æ©™è‰²è¡¨ç¤ºæ ¹èŠ‚ç‚¹æ”¶èµ·
                            return "#e74c3c"; // çº¢è‰²è¡¨ç¤ºæ ¹èŠ‚ç‚¹å±•å¼€æˆ–æ— å­èŠ‚ç‚¹
                        }
                        const hasChildren = this.children.has(d.data.id) && this.children.get(d.data.id).length > 0;
                        const isExpanded = this.expandedNodes.has(d.data.id);
                        if (hasChildren && !isExpanded) return "#f39c12";
                        if (hasChildren && isExpanded) return "#27ae60";
                        return "#3498db";
                    })
                    .style("stroke", d => {
                        if (d.data.id === this.selectedNode) return "#e74c3c";
                        const hasChildren = this.children.has(d.data.id) && this.children.get(d.data.id).length > 0;
                        return hasChildren ? "#34495e" : "#7f8c8d";
                    })
                    .style("stroke-width", d => {
                        if (d.data.id === this.selectedNode) return 3;
                        return d.data.id === this.currentRoot ? 3 : 2;
                    });
                
                // æ›´æ–°çŠ¶æ€æ–‡æœ¬ä½ç½®
                nodeSelection.select(".node-status")
                    .attr("dy", d => {
                        const offset = this.selectedFields.length > 0 ? this.selectedFields.length * 1.0 + 0.8 : 1.5;
                        return `${offset}em`;
                    })
                    .text(d => {
                        const hasChildren = this.children.has(d.data.id) && this.children.get(d.data.id).length > 0;
                        // if (hasChildren) {
                        //     const childCount = this.children.get(d.data.id).length;
                        //     const isExpanded = this.expandedNodes.has(d.data.id);
                        //     const status = isExpanded ? 'å±•å¼€' : 'æ”¶èµ·';
                        //     return `${status}(${childCount})`;
                        // }
                        return '';
                    });
            }

            buildHierarchyData(nodeId) {
                const nodeData = this.data.get(nodeId);
                if (!nodeData) return null;
                
                const children = this.children.get(nodeId) || [];
                const result = { id: nodeId, data: nodeData };
                
                // åªæœ‰å½“èŠ‚ç‚¹è¢«å±•å¼€æ—¶æ‰åŠ è½½å­èŠ‚ç‚¹ï¼ˆåŒ…æ‹¬æ ¹èŠ‚ç‚¹ï¼‰
                if (children.length > 0 && this.expandedNodes.has(nodeId)) {
                    result.children = children.map(childId => this.buildHierarchyData(childId)).filter(child => child !== null);
                }
                
                return result;
            }

            selectNode(nodeId) {
                this.selectedNode = nodeId;
                // æ›´æ–°æ‰€æœ‰èŠ‚ç‚¹çš„é€‰ä¸­çŠ¶æ€
                this.g.selectAll(".node circle")
                    .style("stroke-width", d => {
                        if (d.data.id === nodeId) return 3;
                        return d.data.id === this.currentRoot ? 3 : 2;
                    })
                    .style("stroke", d => {
                        if (d.data.id === nodeId) return "#e74c3c";
                        const hasChildren = this.children.has(d.data.id) && this.children.get(d.data.id).length > 0;
                        return hasChildren ? "#34495e" : "#7f8c8d";
                    });
                
                this.updateNodeDetail(nodeId);
            }
            
            handleNodeClick(event, d) {
                const nodeId = d.data.id;
                const hasChildren = this.children.has(nodeId) && this.children.get(nodeId).length > 0;
                
                // å§‹ç»ˆé€‰ä¸­èŠ‚ç‚¹å¹¶æ˜¾ç¤ºè¯¦æƒ…
                this.selectNode(nodeId);
                
                // å¦‚æœæœ‰å­èŠ‚ç‚¹ï¼ŒåŒæ—¶åˆ‡æ¢å±•å¼€/æ”¶ç¼©çŠ¶æ€
                if (hasChildren) {
                    if (this.expandedNodes.has(nodeId)) {
                        this.expandedNodes.delete(nodeId);
                    } else {
                        this.expandedNodes.add(nodeId);
                    }
                    // ä½¿ç”¨å±€éƒ¨åŠ¨ç”»æ›´æ–°ï¼Œä»å½“å‰èŠ‚ç‚¹å¼€å§‹
                    this.renderTree(nodeId);
                } else {
                    // å¦‚æœæ²¡æœ‰å­èŠ‚ç‚¹ï¼Œåªæ˜¯ç‚¹å‡»é€‰ä¸­ï¼Œå°†è§†å›¾ç§»åŠ¨åˆ°è¯¥èŠ‚ç‚¹
                    this.centerOnNode(nodeId);
                }
            }
            
            toggleNode(nodeId) {
                const hasChildren = this.children.has(nodeId) && this.children.get(nodeId).length > 0;
                if (!hasChildren) return;
                
                if (this.expandedNodes.has(nodeId)) {
                    this.expandedNodes.delete(nodeId);
                } else {
                    this.expandedNodes.add(nodeId);
                }
                
                this.renderTree();
            }


            updateNodeDetail(nodeId) {
                const nodeData = this.data.get(nodeId);
                if (!nodeData) return;
                
                const container = document.getElementById('nodeDetailContent');
                let html = '';
                
                // æ˜¾ç¤ºåŸºæœ¬ä¿¡æ¯
                html += `<div class="info-item"><div class="info-label">èŠ‚ç‚¹ID</div><div class="info-value">${nodeId}</div></div>`;
                
                // æ˜¾ç¤ºæ‰€æœ‰åˆ—æ•°æ®
                for (const [columnName, value] of Object.entries(nodeData.columns)) {
                    if (value && value.toString().trim() && columnName !== 'ID' && columnName !== 'ä¸Šçº§ID') {
                        const displayValue = value.toString();
                        html += `<div class="info-item"><div class="info-label">${columnName}</div><div class="info-value">${displayValue}</div></div>`;
                    }
                }
                
                // æ˜¾ç¤ºçˆ¶èŠ‚ç‚¹ä¿¡æ¯
                if (nodeData.parentId) {
                    html += `<div class="info-item"><div class="info-label">ä¸Šçº§èŠ‚ç‚¹</div><div class="info-value">${nodeData.parentId}</div></div>`;
                } else {
                    html += `<div class="info-item"><div class="info-label">èŠ‚ç‚¹ç±»å‹</div><div class="info-value">æ ¹èŠ‚ç‚¹</div></div>`;
                }
                
                container.innerHTML = html;
            }

            searchNode() {
                const searchTerm = document.getElementById('searchInput').value.trim().toLowerCase();
                if (!searchTerm) { alert('è¯·è¾“å…¥è¦æœç´¢çš„å†…å®¹'); return; }
                const foundId = this.searchIndex.get(searchTerm);
                if (foundId) { this.highlightNode(foundId); return; }
                const matches = [];
                for (const [key, id] of this.searchIndex) {
                    if (key.includes(searchTerm)) matches.push(id);
                }
                if (matches.length === 0) {
                    alert(`æœªæ‰¾åˆ°åŒ…å« "${searchTerm}" çš„èŠ‚ç‚¹`);
                } else if (matches.length === 1) {
                    this.highlightNode(matches[0]);
                } else {
                    const choice = prompt(`æ‰¾åˆ° ${matches.length} ä¸ªåŒ¹é…ç»“æœ:\n${matches.slice(0, 10).join(', ')}\n\nè¯·è¾“å…¥è¦æŸ¥çœ‹çš„ID:`);
                    if (choice && this.data.has(choice)) this.highlightNode(choice);
                }
            }

            highlightNode(nodeId) {
                const nodeData = this.data.get(nodeId);
                if (!nodeData) return;
                
                const rootPath = this.getPathToRoot(nodeId);
                if (rootPath.length > 0) {
                    const nodeRoot = rootPath[0];
                    if (nodeRoot !== this.currentRoot) {
                        this.currentRoot = nodeRoot;
                        document.getElementById('rootSelector').value = nodeRoot;
                        this.expandedNodes.clear();
                    }
                    
                    // å±•å¼€åˆ°ç›®æ ‡èŠ‚ç‚¹çš„è·¯å¾„
                    for (let i = 0; i < rootPath.length - 1; i++) {
                        this.expandedNodes.add(rootPath[i]);
                    }
                    
                    this.renderTree();
                }
                
                // é€‰ä¸­ç›®æ ‡èŠ‚ç‚¹
                this.selectNode(nodeId);
                
                // è‡ªåŠ¨å°†è§†å›¾ç§»åŠ¨åˆ°ç›®æ ‡èŠ‚ç‚¹
                this.centerOnNode(nodeId);
            }

            getPathToRoot(nodeId) {
                const path = [];
                let current = nodeId;
                while (current && this.data.has(current)) {
                    path.push(current);
                    current = this.data.get(current).parentId;
                }
                return path.reverse();
            }

            updateStats() {
                document.getElementById('totalNodesCount').textContent = this.data.size;
                document.getElementById('rootNodesCount').textContent = this.rootNodes.length;
                let maxDepth = 0;
                for (const nodeData of this.data.values()) {
                    maxDepth = Math.max(maxDepth, nodeData.level);
                }
                document.getElementById('maxDepthValue').textContent = maxDepth;
                const currentRootData = this.data.get(this.currentRoot);
                document.getElementById('currentRootValue').textContent = currentRootData ? 
                    `${this.currentRoot}(${this.getDisplayName(currentRootData)})` : 'æ— ';
            }

            resetView() {
                // æ¸…ç©ºæœç´¢æ¡†
                document.getElementById('searchInput').value = '';
                
                // å¦‚æœæœ‰æ•°æ®ï¼Œé‡æ–°æ¸²æŸ“æ•´ä¸ªè§†å›¾
                if (this.fileContent && this.data.size > 0) {
                    // é‡æ–°è§£æå¹¶æ¸²æŸ“æ•°æ®
                    this.parseFileWithOptions();
                } else if (this.rootNodes.length > 0) {
                    // å¦‚æœæ²¡æœ‰æ–‡ä»¶å†…å®¹ä½†æœ‰æ•°æ®ï¼Œé‡ç½®åˆ°åˆå§‹çŠ¶æ€
                    this.currentRoot = this.rootNodes[0];
                    document.getElementById('rootSelector').value = this.currentRoot;
                    // é‡ç½®é€‰ä¸­èŠ‚ç‚¹
                    this.selectedNode = null;
                    // é‡ç½®å±•å¼€çŠ¶æ€ï¼Œä½†é»˜è®¤å±•å¼€æ ¹èŠ‚ç‚¹
                    this.expandedNodes.clear();
                    this.expandedNodes.add(this.currentRoot);
                    // é‡æ–°æ¸²æŸ“æ ‘
                    this.renderTree();
                    // é€‚åº”å±å¹•
                    setTimeout(() => this.fitToScreen(), 100);
                }
            }

            zoomIn() { this.svg.transition().call(this.zoom.scaleBy, 1.5); }
            zoomOut() { this.svg.transition().call(this.zoom.scaleBy, 1 / 1.5); }
            
            centerOnNode(nodeId) {
                // åœ¨D3æ ‘æ•°æ®ç»“æ„ä¸­æ‰¾åˆ°ç›®æ ‡èŠ‚ç‚¹
                if (!this.root) return;
                
                const targetNode = this.root.descendants().find(d => d.data.id === nodeId);
                if (!targetNode) {
                    // å¦‚æœæ‰¾ä¸åˆ°èŠ‚ç‚¹ï¼Œå»¶è¿Ÿä¸€ç‚¹å†è¯•ï¼ˆå¯èƒ½æ­£åœ¨åŠ¨ç”»ä¸­ï¼‰
                    setTimeout(() => this.centerOnNode(nodeId), 200);
                    return;
                }
                
                // ä½¿ç”¨D3æ ‘å¸ƒå±€ä¸­èŠ‚ç‚¹çš„x,yåæ ‡
                const nodeX = targetNode.x;
                const nodeY = targetNode.y;
                
                // è·å–SVGå®¹å™¨å°ºå¯¸
                const parent = this.svg.node().getBoundingClientRect();
                const containerCenterX = parent.width / 2;
                const containerCenterY = parent.height / 2;
                
                // è·å–å½“å‰å˜æ¢çŠ¶æ€
                const currentTransform = d3.zoomTransform(this.svg.node());
                
                // è®¡ç®—æ–°çš„å˜æ¢ï¼Œä½¿èŠ‚ç‚¹åœ¨æ•°æ®åæ ‡ç³»ä¸­çš„ä½ç½®ç§»åŠ¨åˆ°å®¹å™¨ä¸­å¿ƒ
                const newTranslateX = containerCenterX - nodeX * currentTransform.k;
                const newTranslateY = containerCenterY - nodeY * currentTransform.k;
                
                // å¹³æ»‘è¿‡æ¸¡åˆ°ç›®æ ‡ä½ç½®
                this.svg.transition()
                    .duration(750)
                    .call(this.zoom.transform, d3.zoomIdentity.translate(newTranslateX, newTranslateY).scale(currentTransform.k));
            }
            fitToScreen() {
                // å¦‚æœæœ‰é€‰ä¸­çš„èŠ‚ç‚¹ï¼Œä»¥é€‰ä¸­èŠ‚ç‚¹ä¸ºä¸­å¿ƒï¼Œå¦åˆ™ä½¿ç”¨æ•´ä¸ªè§†å›¾
                if (this.selectedNode) {
                    this.centerOnNode(this.selectedNode);
                } else {
                    const bounds = this.g.node().getBBox();
                    const parent = this.svg.node().getBoundingClientRect();
                    const fullWidth = parent.width, fullHeight = parent.height;
                    const width = bounds.width, height = bounds.height;
                    const midX = bounds.x + width / 2, midY = bounds.y + height / 2;
                    if (width == 0 || height == 0) return;
                    const scale = Math.min(fullWidth / width, fullHeight / height) * 0.8;
                    const translate = [fullWidth / 2 - scale * midX, fullHeight / 2 - scale * midY];
                    this.svg.transition().call(this.zoom.transform, d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale));
                }
            }

            expandAll() {
                // å±•å¼€æ‰€æœ‰æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹
                for (const [nodeId, children] of this.children) {
                    if (children.length > 0) {
                        this.expandedNodes.add(nodeId);
                    }
                }
                this.renderTree();
            }
            
            collapseAll() {
                // æ”¶ç¼©æ‰€æœ‰èŠ‚ç‚¹ï¼Œä¿ç•™æ ¹èŠ‚ç‚¹å±•å¼€
                this.expandedNodes.clear();
                this.renderTree();
            }
        }

        // åˆå§‹åŒ–åº”ç”¨
        const treeViewer = new D3TreeViewer();
    </script>
</body>
</html>